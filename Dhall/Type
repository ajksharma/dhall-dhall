{- The Dhall AST.

   Differences from Haskell:
 - no `Note` node (use `EnvT` instead)
 - `OptionalLit` uses `Either` instead of always needing a type
 - no `Some` or `None` nodes (these map to `OptionalLit`)
 - `Map` and `Set` are replaced by `List`, which maintains order, but not
   uniqueness.
-}
    let Either =
          https://raw.githubusercontent.com/FormationAI/dhall-bhat/a49f366e6f0e5815ee118b73b93685e5fa0ef1fa/Either/Type

in    λ(embed : Type)
    → λ(a : Type)
    → < Const :
          ./Const
      | Var :
          ./Var
      | Lam :
          { name : Text, input : a, output : a }
      | Pi :
          { name : Text, input : a, output : a }
      | App :
          { function : a, argument : a }
      | Let :
          { name : Text, type : Optional a, binding : a, body : a }
      | Annot :
          { term : a, type : a }
      | Bool/Type :
          {}
      | Bool/Lit :
          Bool
      | Bool/and :
          { _1 : a, _2 : a }
      | Bool/or :
          { _1 : a, _2 : a }
      | Bool/eq :
          { _1 : a, _2 : a }
      | Bool/ne :
          { _1 : a, _2 : a }
      | Bool/if :
          { condition : a, consequent : a, alternative : a }
      | NaturalType :
          {}
      | NaturalLit :
          Natural
      | NaturalFold :
          {}
      | NaturalBuild :
          {}
      | NaturalIsZero :
          {}
      | NaturalEven :
          {}
      | NaturalOdd :
          {}
      | NaturalToInteger :
          {}
      | NaturalShow :
          {}
      | NaturalPlus :
          { _1 : a, _2 : a }
      | NaturalTimes :
          { _1 : a, _2 : a }
      | IntegerType :
          {}
      | IntegerLit :
          Integer
      | IntegerShow :
          {}
      | IntegerToDouble :
          {}
      | DoubleType :
          {}
      | DoubleLit :
          Double
      | DoubleShow :
          {}
      | TextType :
          {}
      | TextLit :
          Text
      | TextAppend :
          { first : a, second : a }
      | ListType :
          {}
      | ListLit :
          { type : Optional a, elems : List a }
      | ListAppend :
          { first : a, second : a }
      | ListBuild :
          {}
      | ListFold :
          {}
      | ListLength :
          {}
      | ListHead :
          {}
      | ListLast :
          {}
      | ListReverse :
          {}
      | OptionalType :
          {}
      | OptionalLit :
          ./Either a a
      | OptionalFold :
          {}
      | OptionalBuild :
          {}
      | RecordType :
          List { name : Text, type : a }
      | RecordLit :
          List { name : Text, value : a }
      | Union :
          List { name : Text, type : a }
      | UnionLit :
          { value : a, type : List { name : Text, type : a } }
      | Combine :
          { _1 : a, _2 : a }
      | CombineTypes :
          { _1 : a, _2 : a }
      | Prefer :
          { original : a, preferred : a }
      | Merge :
          { handlers : a, union : a, type : Optional a }
      | Constructors :
          a
      | Field :
          { structure : a, name : Text }
      | Project :
          { structure : a, names : List Text }
      | ImportAlt :
          { primary : a, fallback : a }
      | Embed :
          embed
      >
